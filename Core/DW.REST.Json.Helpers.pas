unit DW.REST.Json.Helpers;

interface

uses
  System.JSON, REST.Json;

type
  TJsonHelper = class helper for TJson
  public
    /// <summary>
    ///   Replacement functions for TJson.Format, which does not format correctly
    /// </summary>
    /// <remarks>
    ///   Overload that takes a string parameter has been modified so that it should also work for JSON which is not generated by TJsonValue.ToString
    ///   Please use theis function with CAUTION!! It still may not cater for all situations
    /// </remarks>
    class function Tidy(const AJsonValue: TJsonValue; const AIndentSize: Integer = 2): string; overload; static;
    class function Tidy(const AJson: string; const AIndentSize: Integer = 2): string; overload; static;
  end;

implementation

uses
  System.Character;

class function TJsonHelper.Tidy(const AJsonValue: TJsonValue; const AIndentSize: Integer = 2): string;
begin
  Tidy(AJsonValue.ToString, AIndentSize);
end;

class function TJsonHelper.Tidy(const AJson: string; const AIndentSize: Integer = 2): string;
const
  cEOL = #13#10;
var
  LChar: Char;
  LIndent: string;
  LLevel: Integer;
  LIsEOL, LIsInString, LIsEscape, LIsObjectEnd: boolean;
begin
  Result := '';
  LIsEOL := True;
  LIsInString := False;
  LIsEscape := False;
  LIsObjectEnd := False;
  LIndent := '';
  LLevel := 0;
  for LChar in AJson do
  begin
    if not LIsInString and (LChar = '{') then
    begin
      if not LIsEOL then
        Result := Result + cEOL;
      Result := Result + LIndent + LChar + cEOL;
      Inc(LLevel);
      LIndent := StringOfChar(' ', LLevel * AIndentSize);
      Result := Result + LIndent;
      LIsEOL := True;
    end
    else if not LIsInString and (LChar = '[') then
    begin
      LIsEOL := True;
      Result := Result + LChar + cEOL;
      Inc(LLevel);
      LIndent := StringOfChar(' ', LLevel * AIndentSize);
    end
    else if not LIsInString and (LChar = ',') then
    begin
      LIsEOL := False;
      Result := Result + LChar + cEOL + LIndent;
    end
    else if not LIsInString and (LChar = '}') then
    begin
      Dec(LLevel);
      LIndent := StringOfChar(' ', LLevel * AIndentSize);
      if not LIsEOL or LIsObjectEnd then
        Result := Result + cEOL;
      Result := Result + LIndent + LChar;
      LIsEOL := True;
      LIsObjectEnd := True;
    end
    else if not LIsInString and (LChar = ']') then
    begin
      Dec(LLevel);
      LIndent := StringOfChar(' ', LLevel * AIndentSize);
      LIsEOL := True;
      Result := Result + cEOL + LIndent + LChar;
    end
    else if not LIsInString and LIsEscape and (LChar = '\') then
    begin
      LIsEscape := False;
    end
    else if not LChar.IsInArray([#13, #10, #32]) then
    begin
      LIsEOL := False;
      Result := Result + LChar;
      if not LIsInString and (LChar = ':') then
        Result := Result + ' ';
    end;
    if not LChar.IsInArray([#13, #10, #32]) and (LChar <> '}') then
      LIsObjectEnd := False;
    LIsEscape := (LChar = '\') and not LIsEscape;
    if not LIsEscape and (LChar = '"') then
      LIsInString := not LIsInString;
  end;
end;

end.
